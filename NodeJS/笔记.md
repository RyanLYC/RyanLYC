


### SSO 和 OAuth2
* SSO 单点登录
* OAuth2第三方鉴权的常用方式
#### 多系统登录 使用 cookie实现
简单的，如果业务系统都在同一主域名下，比如 wenku.baidu.com tieba.baidu.com ，就好办了。可以直接把 cookie domain 设置为baidu.com，百度也就是这么干的
#### SSO
复杂一点的，滴滴这么潮的公司，同时拥有 didichuxing.com xiaukeii.com didiglobal.com 等域名，    
系统A 与 系统B 共享登录   
客户端-> 访问系统A，凭证失效 需要登录（可以通过SSO之后生产自己的token）-> 重定向到SSO -> 访问SSO，校验 无凭证 -> 需要登录帐号密码 -> 返回ticket（token）SSO凭证 -> 客户端存储-> 访问系统A，（生成自己的token） -> 校验 -> 进入系统A |||| 进入系统B -> 拿ticket（token） 访问系统B，凭证失效 需要登录（可以通过SSO之后生产自己的token）-> 需要登录 -> 访问SSO  -> 校验成功 -> 访问系统B

#### OAuth2
上述 SSO 是 oauth 的实际案例，其他常见的还有微信登录、github 登录等。即，当设计到第三方用户登录校验时，都会使用 OAuth2.0 标准

### 单元测试 和 接口测试
* jest 和 Mocha 测试工具
* supertest 发请求进行 + jest进行 接口测试  本地测试
* 远程测试 jest + axios 发布到测试机 测试

#### 测试区栋开发 TDD
Test-Driven Development 。是一种不同于传统软件开发流程的新型的开发方法。它要求在编写某个功能的代码之前先编写测试代码，然后只编写使测试通过的功能代码，通过测试来推动整个开发的进行，这有助于编写简洁可用和高质量的代码，并加速开发过程。

### pm2 和 nginx

* 进程守护 - 稳定
* 多进程 - 高效
* 日志记录 - 问题可追溯

#### pm2
安装  npm i pm2 -g      
pm2配置 在 bin/ 目录下    
##### 基本使用
* 启动：pm2 start xxx.js
* 重启：pm2 restart <id/name>
* 重载：pm2 reload
* 列表：pm2 list
* 日志：pm2 logs <id/name>
* 停止：pm2 stop <id/name>
* 删除：pm2 delete <id/name>
* 监控：pm2 monit 
```javascript
const os = require('os')
const cpuCoreLength = os.cpus().length // CPU 几核
module.exports = {
apps: [
  {
    name: 'your-server-name',
    script:'bin/www',
    // watch: true，// 无特殊情况，不用实时监听文件，否则可能会导致很多 restart
    ignore_watch: ['node modules','__test__','logs'],
    //instances: cpuCoreLength，// 线上环境，多进程
    instances: 1，// 测试环境，一个进程即可
    error_file:'./logs/err.log',
    out_file: './logs/out.log',
    Log_date_format:'YYYY-MM-DD HH:mm:ss z'，// Z 表示使用当前时区的时间格式
    combine_logs: true，// 多个实例，合并日志
    max_memory_restart:'300M'，// 内存占用超过 300M ，则重启
  }
],
}
```
##### 日志拆分 pm2-logrotate
* 安装插件 - 使用 ​​pm2​​ 进行安装  -  pm2 install pm2-logrotate
* 安装完以后， 通过 ​​pm2 list​​​ 可以查看到 ​​pm2-logrotate​​ 的进程。
* pm2-logrotate 修改 默认设置 pm2 set pm2-logrotate:max_size 10M # 日志最大 10M 等等

### Nginx
​nginx​​​ 一直是 ​​web server​​ 的必备神器，以稳定和高性能著称。

* 静态服务（​​html​​​，​​css​​​，​​js​​ 等静态资源访问）
* 反向代理
* 负载均衡 （大公司 运维）
​​* Access log​​

#### 安装 nginx
1. nginx 官方下载​ - 下载完后直接解压，然后进入解压目录，打开 ​​cmd​​​，执行 ​​start nginx.exe​​
2. 浏览器访问 ​​http://127.0.0.1/​​ ， 出现界面证明启动成功。

#### 常用命令
* 启动：nginx
* 重启：nginx -s reload
* 停止：nginx -s stop
* 测试配置文件：nginx -t
* 指定配置文件：nginx -c xxx.conf

### 服务端 CI/CD 测试机(低配 系统 cnetos7.x)  Docker Docker-compose github actions 
#### Github actions
网上的 CI/CD 有很多，例如 travis ，任选一个即可Github actions 高效稳定，功能强大   

使用Github actions 做构建和测试   

#### 认识 github action
Github 2019 年秋天发布的 CI/CD 工具，功能强大且稳定    
Github 被微软收购之后，越来越强大了，正在由一个 git 托管服务，变为一个研发项目解决方案    

* 介绍 github 项目的 Actions
* 中文文档https:/docs.github.com/cn/free-pro-team@latest/actions/learn-github-actions

 代码在项目的.github/workflows 目录下，yml 格式文件  

 ##### 应该场景
* master 分支，自动化测试
* dev 分支，自动部署到测试机
* v*.*.* 格式的tag，自动上线（支持回滚）

##### 使用 
1. ​github​​​ 仓库，然后点击 ​​actions​​ 选择 模板，输入 name 就会在项目的 ​​.github/workflows​​​ 目录下，生成 ​​.yml​​ 文件。代码仓库多了一个文件
2. 本地拉一下代码，可以看到 ​​.yml​​ 文件已经存在了。
3. 配置文件
```javascript
# master 分支 自动测试

name: test # 测试名称 语义化即可

on: # 触发条件
    push: # 在下面的分支进行 push 操作的时候触发
        branches: # 触发的分支 可以设置多个
            - main # 分支名称
        paths: # 以下目录中的文件有改动就触发  可以不写 代表所有文件
            - '.github/workflows/**'
            - '__test__/**'
            - 'src/**'

jobs: # 任务
    test: # 任务名称 可以自定义 也可以使用第三方
        runs-on: ubuntu-latest # 指定运行环境 操作系统 没有特殊情况不需要改
        steps: # 步骤
            - uses: actions/checkout@v2 # 第一个步骤   第三方的actions   等同于执行了 git pull
            - name: Use Node.js # 第二个步骤 步骤名称 自定义
              uses: actions/setup-node@v1 #  第三方的actions   安装 node.js
              with: # 参数
                  node-version: 14 # nodejs 的版本
            - name: lint and test # 第三个步骤 步骤名称 自定义
              run: | # 自定义执行命令  多行的方式
                  npm i
                  npm run lint
                  npm run test:remote
    test2: # 任务名称 可以自定义 也可以使用第三方
        runs-on: ubuntu-latest # 指定运行环境 操作系统 没有特殊情况不需要改
        steps: # 步骤
            - run: touch a.txt # 自定义执行命令  单行的方式
            - run: echo 100 > a.txt # a.text 写入内容
            - run: cat a.txt # 读取  a.text 内容

```
4. step 的四种方式
```javascript
# 一 直接使用 uses 第三方
 - uses: actions/checkout@v2
 # 二 使用 name + uses 第三方
 - name: Use Node.js
   uses: actions/setup-node@v1
 # 三 run  |  多行的方式
 run: |
      npm i
      npm run test:remote
 # 四 run 单行的方式
    - run: touch a.txt
    - run: echo 100 > a.txt
    - run: cat a.txt
```

### Docker
基于Docker，我们可以把开发、测试环境，一键部署到任何一台机器上。只要机器安装了Docker   
`安装完成后需要 docker镜像加速 修改源`

#### Window 安装 docker
1. 查看是否可以安装 Hyper-V 虚拟机功能    
   打开命令提示符，输入 ​​systeminfo​​，查看最后四个Hyper-V配置是不是全都是 是 。  
2. 安装 Hyper-V
   将下面的内容复制到记事本当中，并保存为 ​​Hyper-V.cmd​​    
```javascript
pushd "%~dp0"
dir /b %SystemRoot%\servicing\Packages\*Hyper-V*.mum >hyper-v.txt
for /f %%i in ('findstr /i . hyper-v.txt 2^>nul') do dism /online /norestart /add-package:"%SystemRoot%\servicing\Packages\%%i"
```
然后右键点击这个文件 以管理员身份运行（A），然后弹出一个验证对话，点击 是，紧接着进行 ​​Windows​​ 命令处理，我们等待处理完成以后，电脑自动重启，进行配置更新  
3. 启用 Hyper-V ; 控制面板  程序和功能 - 启动或关闭Window功能 - 确认Hyper-V复选框已经被勾选，并单击确定按钮。
4. 安装 Docker - 官网 -然后等待下载完成，以管理员身份运行（A） 安装包，过程按照引导安装就行，安装完成后，会引导你重启计算机。
5. 出现提升 WSL2 instllation is incomplete 警告 - 点击链接下载安装更新 即可
6. 打开命令行或者 ​​PowerShell​​​ 界面，并执行 ​​docker version​​ 命令，如果出现以下信息说明安装成功。
7. Docker 镜像加速 - "registry-mirrors": ["http://hub-mirror.c.163.com","https://mirror.ccs.tencentyun.com"],

##### 常用命令
* 下载镜像：​​docker pull <image-name>:<tag>​​
* 查看所有镜像​​docker images​​
* 删除镜像​​docker rmi <image-id>​​
* 上传镜像​​docker push <username>/<repository>:<tag​​​>，要先注册​​hub.docker.com​​
* 如果 ​​docker images​​​ 出现 ​​REPOSITORY​​​ 是 ​​<none>​​​ 的情况，可以先运行 ​​docker image prune​​ 删除。
* 所有的 ​​id​​ 不需要完全输入，只需要输入前几位能够区分开就可以。

##### container 容器
启动容器​​ docker run -p xxxx:xxx -v=hostPath:containerPath -d --name <container-name><image-name>
* -p 端口映射
* -v 数据卷，文件映射
* -d 后台运行
* --name 定义容器名称​​

1. 查看所有容器​​docker ps​​​，加​​-a​​ 显示隐藏的容器
2. 停止容器​​docker stop <container-id>​​
3. 删除容器​​docker rm <container-id> ​​​，加​​-f​​ 是强制删除
4. 查看容器信息，如​​IP​​​ 地址​​docker inspect <container-id>​​
5. 查看容器日志​​ docker logs <container-id>​​
6. 进入容器控制台​​docker exec -it <container-id> /bin/sh​​

#### 启动一个 Docker 容器 nginx 例子
1. 下载 nginx 镜像 - 执行 ​​docker pull nginx​​​，可以看到没有输入版本，默认下载 ​​latest​​ 的。
2. 查看镜像 - 执行 ​​docker images​​，查看所有镜像。
3. 启动容器 - 执行 ​​docker run -p 81:80 -d --name myNginx nginx​​​ ，会返回一个 ​​id​​。
4. 执行 ​​docker ps​​ 查看容器列表。
5. 访问 nginx - 访问 ​​http://localhost:81/​​​ ，可以看到 ​​nginx​​ 的默认页，说明容器已经启动成功了。
6. 查看容器信息 执行 ​​docker inspect <id>​​，可以看到容器信息，非常的多。
7. 查看容器日志 执行 ​​docker logs <id>​​，可以看到容器日志，方便排查问题。
8. 进入容器控制台 执行 ​​docker exec -it <id> /bin/sh​​，可以进入到容器的控制台。
9. 执行 ​​exit​​ 就可以退出控制台。
10. 停止容器 执行 ​​docker stop <id>​​ ，就可以停止容器。
11. 删除容器 执行 ​​docker ps -a​​ 可以看到刚才被停止的容器依然存在。 - 执行 ​​docker rm <id> ​​ 可以删除容器，这次再查看就不在列表里了。
12. 文件映射 - 在启动容器的时候加上参数 ​​-v xxxx：xxx​​，冒号前面是宿主机（本地）的地址，冒号后面是虚拟机的地址 - docker run -p 81:80 -d -v D:/test:/usr/share/nginx/html --name myNginx nginx
13. 这个时候再访问 ​​nginx​​ ，就映射到我们本地的文件上面来了。

### 服务端开发之 Dockerfile
* 一个简单的配置文件，描述如果构建一个新的 ​​image​​ 镜像。
* .dockerignore  类似于 ​​.gitignore​​​ ， 可以把对 ​​docker​​ 没有用的文件忽略掉。
#### 语法
```shell
    # .dockerignore
    # 基于哪个镜像的基础上进行构建
    FROM node:14
    # 工作目录
    WORKDIR /app
    # 拷贝当前目录下的文件 到 /app 中  .dockerignore 文件中可以声明忽略拷贝的文件
    COPY  . /app

    # 构建镜像时, 一般用于做一些系统配置, 安装必备的软件, 可有多个 RUN
    RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo 'Asia/Shanghai' > /etc/timezone
    RUN npm set registry  https://registry.npmmirror.com
    RUN npm install

    # 启动容器时, 只能有一个 CMD
    # npx pm2 log  cmd 最后的命令是一个阻塞控制台的程序
    CMD echo $SERVER_NAME && echo $SERVER_NAME && npm run dev && npx pm2 log

    # 环境变量
    ENV SERVER_NAME='editor-server'
    ENV AUTHOR_NAME='warbler'
```
#### 用 Dockerfile 构建镜像
最后的 . 指 Dockerfile   
* docker build -t editor-server .   
* 执行以下命令，查看是否有刚才的镜像 docker images
```java
// 启动容器
docker run -p 8081:3000 -d --name server1 editor-server
// 查看容器列表
docker ps
// 查看容器日志
```

 
### Docker-compose
通过一个配置文件，可以让系统一键启动所有的运行环境，​​nodejs​​​，​​mysql​​​，​​redis​​​，​​mongodb​​ 等。   
如果开发环境需要多个服务，就需要启动多个 ​​Docker​​ 容器。    
要连通多个 ​​Docker​​​ 容器，就需要 ​​Docker-compose​​。   
#### 安装
​​Docker Desktop for Windows​​​ 自带 ​​docker-compose​​   
查看 docker-compose 版本   
docker-compose --version   ( 2.0 以上 版本 docker compose version)
#### 配置文件
```shell
# 统一的版本号
version: '3'
services:
    editor-server: # service name
        build:
            context: . # 当前目录
            dockerfile: Dockerfile # 基于 Dockerfile 构建
        image: editor-server # 依赖于当前 Dockerfile 创建出来的镜像
        container_name: editor-server
        ports:
            - 8081:3000 # 宿主机通过 8081 访问
    editor-redis: # service name，重要！
        image: redis # 引用官网 redis 镜像
        container_name: editor-redis
        ports:
            # 宿主机，可以用 127.0.0.1:6378 即可连接容器中的数据库
            # 但是，其他 docker 容器不能，因为此时 127.0.0.1 是 docker 容器本身，而不是宿主机
            - 6378:6379
        environment:
            - TZ=Asia/Shanghai # 设置时区
    editor-mysql:
        image: mysql # 引用官网 mysql 镜像
        container_name: editor-mysql
        restart: always # 出错则重启
        privileged: true # 高权限，执行下面的 mysql/init
        command: --default-authentication-plugin=mysql_native_password # 远程访问
        ports:
            - 3305:3306 # 宿主机可以用 127.0.0.1:3305 即可连接容器中的数据库，和 redis 一样
        volumes:
            - .docker-volumes/mysql/log:/var/log/mysql # 记录日志
            - .docker-volumes/mysql/data:/var/lib/mysql # 数据持久化
            - ./mysql/init:/docker-entrypoint-initdb.d/ # 初始化 sql
        environment:
            # 初始化容器时创建数据库
            # - MYSQL_USER=user #创建 test 用户
            # - MYSQL_PASSWORD=userpsw #设置 test 用户的密码
            - MYSQL_DATABASE=editor_db # 初始化容器时创建数据库
            - MYSQL_ROOT_PASSWORD=ryanmysql
            - TZ=Asia/Shanghai # 设置时区
    editor-mongo:
        image: mongo # 引用官网 mongo 镜像
        container_name: editor-mongo
        restart: always
        volumes:
            - '.docker-volumes/mongo/data:/data/db' # 数据持久化
        environment:
            - MONGO_INITDB_DATABASE=editor_db
            - TZ=Asia/Shanghai # 设置时区
        ports:
            - '27016:27017' # 宿主机可以用 127.0.0.1:27016 即可连接容器中的数据库

```
./mysql/init/init.sql
```sql
-- docker-compose 启动 mysql 时的初始化代码

select "init start...";

-- 设置 root 用户可外网访问
use mysql;
SET SQL_SAFE_UPDATES=0; -- 解除安全模式，测试环境，没关系
update user set host='%' where user='root';
flush privileges;
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'ryanmysql'; -- 密码参考 docker-compose.yml
flush privileges;

select "init end...";

```
#### 命令
* 构建容器 ：docker-compose build
* 启动所有服务器：docker-compose up -d, 后台启动
* 停止所有服务：docker-compose down
* 查看服务：docker-compose ps

### 自动发布到测试机 - 阿里云
ssh root@82.156.xxx.xx
// 然后输入密码

#### 创建 账号
adduser ryan
passwd ryan
// 然后输入两次密码
#### 添加 work 账号的 sudo 权限
```java
// 找到文件位置
whereis sudoers
// 修改权限
chmod u+w /etc/sudoers
// 编辑文件 找到 root ALL=(ALL) ALL 再添加一行(sudo 命令 不用输入密码) ryan ALL=(ALL) NOPASSWD: ALL
vim /etc/sudoers
// 修改权限
chmod u-w /etc/sudoers
```

#### 免密登录 使用ssh-copy-id将SSH公钥上传到Linux服务器
ssh-copy-id username@remote-server

#### 安装必备软件
安装 yum  
安装 ​​git​​  
yum -y install git  
git --version  


docker --version  
docker compose version  

#### 自动发布 步骤
1. 使用 ​​github actions​​​ 监听 ​​main​​​ 分支 ​​push​​ 行为
2. 登录测试机，获取最新 ​​main​​ 分支代码
3. 重新构建镜像，​​docker-compose build editor-server​​
4. 重启所有容器，​​docker-compose up -d​​

##### 临时设置 ssh key 先要 ssh-copy-id username@remote-server
1. 仓库 - Setting是 - Secrets - Actions - New repository secret 
2. C:\Users\Ryan\.ssh\id_rsa   把本机的私钥放在代码仓库 ​​setting​​​ 里面的 ​​Secrets​​ 中 RYAN_EDITOR_SERVICE 
3. 获取代码仓库 需要令牌 github 帐号下 Settings - Developer settings ​​ - ​Generate new token​​ - classic - 选择永不过期，把所有的框都勾选上 -  最后点击 ​​Generate token​​ 生成令牌 - 将生成的令牌拷贝下来，保存，下次就看不到了。
4.  sudo git remote add origin https://令牌@github.com/RyanLYC/editor-service.git; 
5.  具体 看 Editor_Service 代码仓库