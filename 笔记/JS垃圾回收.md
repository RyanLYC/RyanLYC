#### JS 垃圾回收

1. 引用计数算法，赋值+1，覆盖-1，引用次数为 0 可以清理

```js
// 无法清除的例子 - 循环引用
function test() {
  let A = new Object();
  let B = new Object();
  A.b = B;
  B.a = A;
}
```

2. 标记清除算法，进栈使用则标记为 1，出栈后标记为 0，清除时机到了，把所有 0 的全部清除
   这样导致清除之后，空的空间很多，导致内存不连续-内存碎片很多

3. 标记整理清除算法：就是移动内存，让还在使用的内存连续，清除的存放在一起，一起清除

4. V8 引擎内存深度优化
   V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中讲堆内存分为新生代和老生代两个区域，采用不同的垃圾回收策略回收

- 新生代：新生代中一个是使用区，一个是空闲区，开始回收之前进行使用标记，标记完成后把活动对象复制到空闲区并排序，然后清理阶段把使用区变为空闲区，空闲区变为使用区。当一个对象经过多次复制后，依然存在，移动到老生代进行管理。如果一个对象复制到空闲区时，空闲区使用空间超过 25%，那么这个对象直接移动到老生代区。
- 老生代：使用标记整理进行处理。

#### event-loop

- 宏任务
  - I/O
  - setTimeout
  - setInterval
  - setImmediate - 是一个用于在 Node.js 中执行异步操作的函数。它类似于 setTimeout，但是会在当前事件循环的末尾立即执行回调函数，而不是等待一定的延迟时间
  - requestAnimationFrame
- 微任务
  - process.nextTick - 是 Node.js 提供的一个控制流程的函数，它属于事件循环的一个特殊阶段，用于将回调函数推迟到当前执行栈的末尾、但在任何其他异步任务（如 I/O、计时器等）之前执行。它非常适合处理微任务，用于在当前执行栈结束之后、但又不需要等待其他宏任务（如 setTimeout、setImmediate）的情况下执行代码。这对于需要高性能、低延迟的场景非常有用，例如在某些异步操作完成后立即执行清理工作或状态更新。
  - MutationObserver - 用来监视 DOM 变动
  - Promise.then catch finally
- 整体流程
  - 执行一个宏任务（栈中没有就从事件队列中获取）
  - 执行过程中如果遇到微任务，就将它添加到微任务队列中
  - 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务，依次执行
  - 当宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染
  - 渲染完毕后，js 线程继续接管，开始下一个宏任务（从事件队列中获取）

##### Node 中的 event-loop 流程

- timers 这个阶段处理 setTimeout()和 setInterval()定时器相关的任务
- pending callbacks 这个阶段处理除定时器之外，所有通过异步 I/O 操作回调函数返回的任务
- idle、prepare 系统内部使用
- connection、data... -> poll 这个阶段等待新的 I/O 事件并执行回调函数，如果没有新的 I/O 事件到来则等待
- check 这个阶段处理 setImmediate()回调函数
- close callbacks 这个阶段处理套接字和文件句柄的 close 事件

事件循环会不断重复这些阶段，直到事件队列中没有任务为止，然后进入休息等待新的任务到来
