### meta 标签:自动刷新/跳转
跳转   
<meta http-equiv="Refresh" content="5; URL=page2.html">     
自动刷新   
<meta http-equiv="Refresh" content="60">  

### 性能优化
#### JS
1. script 标签:调整加载顺序提升渲染速度
渲染引擎在解析HTML时，若遇到 script 标签引用文件则会暂停解析过程，同时通知网络线程加载文件，文件加载后会切换至JavaScript引警来执行对应代码，代码执行完成之后切换至渲染引擎继续渲染页面。   
script 标签: 调整加载顺序提升染速度 - script 标签的3个属性    
- async属性一一立即请求文件，但不阻塞渲染引擎，文件加载完毕后阻塞渲染引擎并立即执行文件内容
- defer 属性一一立即请求文件，但不阻塞染引擎，等到解析完 HTML 之后再执行文件内容
- HTML5标准type属性--对应值为“module”，让浏览器按照ECMAScript6标准将文件当作模块进行解析，默认阻塞效果同 defer也可以配合async在请求完成后立即执行

2. js 代码放入body标签底部

#### link 标签:通过预处理提升染速度
1. dns-prefetch - 当link标签的rel属性值为“dns-prefetch”时，浏览器会对某个域名预先进行DNS解析并缓存
2. preconnect - 让浏览器在一个HTTP 请求正式发给服务器前预先执行一些操作包括DNS解析、TLS协商、TCP 握手，通过消除往返延迟来为用户节省时间
3. prefetch/preload - 两个值都是让浏览器预先下载并缓存某个资源，但不同的是prefetch 可能会在浏览器忙时被忽略，而 preload 则是一定会被预先下载
4. prerender - 浏览器不仅会加载资源，还会解析执行页面，进行预渲染

### 搜索优化
#### meta标签 - 提取关键信息
<meta  content="关键字,关键字" name="keywords">  
推荐使用一些关键字工具来挑选比如 Google Trends、站长工具

#### link标签 减少重复
对于同一个页面会有多个网址，又或者存在某些重定向页面，比如:   
https://xx.com/a.html   
https://xx.com/detail?id="abcd"   

<link href="https://xx.com/a.html" rel="canonical">    

合共网址的方式。比如使用站点地图，或者在HTTP 请求响应头部添加 rel="canonical"  

###  0GP (Open Graph Protocal，开放图表协议)
OGP 是 Facebook 公司在 2010 年提出的    
目的是通过增加文档信息来提升社交网页在被分享时的预览效果,只需要在一些分享页面中添加一些 meta 标签及属性,支持OGP协议的社交网站就会在解析页面时生成丰富的预览信息   
比如站点名称、网页作者、预览图片   

官网： 官方网站: https://ogp.mel

### 如何高效操作DOM
DOM (Document Object Model，文档对象模型)是JavaScript操作HTML的接口(这里只讨论属于前端范畴的 HTMLDOM)属于前端的入门知识，同样也是核心内容，因为大部分前端功能都需要借助DOM来实现
1. DOM 节点概念区分
- 标签是HTML的基本单位，比如 p、div、input
- 节点是 DOM 树的基本单位，有多种类型，比如注释节点、文本节点
- 元素是节点中的一种，与 HTML标签相对应，比如p标签会对应p元素

<p>亚里士朱德</p>   

- "p"是标签，生成 DOM 树的时候会产生两个节点
* 元素节点 p
* 字符串为“亚里士朱德”的文本节点

2. DOM 操作耗时 因为 两个引擎 渲染引起 & js引擎
   两个引擎是互斥的 多次引擎切换 耗时

3. 重新渲染
- 渲染过程中最耗时的两个步骤为重排 (Reflow) 与重绘 (Repaint)
- 渲染页面时会将HTML和CSS 分别解析成DOM树和CSSOM 树然后合并进行排布，再绘制成我们可见的页面，如果在操作 DOM 时涉及到元素、样式的修改就会引起渲染引擎重新计算样式生成CSSOM树，同时还有可能触发对元素的重新排布 (简称“重排”)和重新绘制(简称“重绘”)    
影响到其他元素排布的操作就会引起重排，继而引发重绘   
比如:
* 修改元素边距、大小
* 添加、删除元素
* 改变窗口大小
重绘
* 设置背景图片
* 修改字体颜色
* 改变visibility 属性值

#### 总结
* 尽量不要使用复杂的匹配规则和复杂的样式从而减少渲染引擎计算样式规则生成CSSOM树的时间
* 尽量减少重排和重绘影响的区域
* 使用CSS3特性来实现动画效果

### DOM事件
1. 防抖
2. 节流

### CSS
* HTML 标签决定了页面的逻辑结构
* CSS决定了页面的视觉结构

CSS提供了import 命令支持文件引用但由于其存在一些问题(比如影响浏览器并行下载、加载顺序错乱等)导致使用率极低   
更常见的做法是通过预处理器或编译工具插件来引入样式文件   

### 浏览器渲染页面
1. 字节流解码
2. 输入流预处理 -  解码后进行预处理，比如换行符转换，生产规范化的字符流数据
3. 令牌化 - 
4. 解释HTML生成DOM树
5. 从CSS到CSSOM  
CSS解析的过程与HTML解析过程步骤一致，最终也会生成树状结构   
CSSOM 树的节点具有继承特性也就是会先继承父节点样式作为当前样式，然后再进行补充或覆盖    
6. 构建渲染树
DOM树包含的结构内容与CSSOM树包含的样式规则都是独立的为了更方便渲染，先需要将它们合并成一棵渲染树
7. 布局 - 布局就是计算元素的大小及位置
8. 绘制 - 绘制就是将渲染树中的每个节点转换成屏幕上的实际像素的过程

### TTTP协议
HTTP/1.0每进行一次通信都需要经历`建立连接`、`传输数据`和`断开连接`三个阶段当一个页面引用了较多的外部文件时这个建立连接和断开连接的过程就会增加大量网络开销,1999年推出的HTTP/11版本增加了一个创建持久连接的方法

#### 三次握手
1. 客服端 closed状态 -> 发送SNY报文和客户端的ISN  -> 服务端 Listen状态
2. 客服端 SYN_SEND状态 <- 发送ACK/SNY报文和客户端的ISN+1,服务端的ISN  <- 服务端 SYN_SEND状态
3. 客服端 ESTABLISHED状态 -> 发送ACK报文和服务端的ISN+1  -> 服务端 ESTABLISHED状态

#### 为什么需要三次握手
- 第一次握手成功让服务端知道了客户端具有发送能力
- 第二次握手成功让客户端知道了服务端具有接收和发送能力
- 第三次握手成功让服务端知道客户端是否接收到了自己发送的消息

#### 四次挥手
1. 客服端 ESTABLISHED状态 -> FIN报文 -> 服务端 ESTABLISHED状态
2. 客服端 FIN_WAIT_1状态 <- ACK报文 <- 服务端 Close_Wait状态
3. 客服端 FIN_WAIT_2状态 <- FIN报文 <- 服务端LAST_ACK状态
4. 客服端 FCLOSED状态 ->ACK报文 -> 服务端 Close_Wait状态

#### 为什么需要四次挥手
当服务端收到客户端的 FIN 报文后，发送的ACK 报文只是用来应答的并不表示服务端也希望立即关闭连接
当只有服务端把所有的报文都发送完了，才会发送FIN 报文告诉客户端可以断开连接了

#### HTTP2 - 使用二进制分帧机制 + HTTPS 加密传输
- 浏览器为了减轻服务器的压力，限制了同一个域下的 HTTP 连接数即6~8个，所以在HTTP/1.1下很容易看到资源文件等待加载的情况,对应优化的方式就是使用多个域名来加载图片资源
- HTTP/1.1本身的问题虽然HTTP/1.1中使用持久连接时，多个请求能共用一个 TCP连接但在一个连接中同一时刻只能处理一个请求,在当前的请求没有结束之前，其他的请求只能处于阻塞状态这种情况被称为`队头阻塞`

### 加快浏览器加载网络资源
- 使用gzip算法压缩响应体内容和HTTP/2的压缩头部功能
- 另一种更通用也更为重要的技术就是使用缓存

#### HTTP 缓存
使用缓存最大的问题往往不在于将资源缓存在什么位置或者如何读写资源，而在于如何保证缓存与实际资源一致的同时提高缓存的命中率，也就是说尽可能地让浏览器从缓存中获取资源，但同时又要保证被使用的缓存与服务端最新的资源保持一致，HTTP支持的缓存策略有两种:`强制缓存`和`协商缓存`

`强制缓存`是在浏览器加载资源的时候先直接从缓存中查找请求结果,如果不存在该缓存结果，则直接向服务端发起请求

1. Expires - HTTP/1.0中可以使用响应头部字段Expires 来设置缓存时间它对应一个未来的时间戳,客户端第一次请求时，服务端会在响应头部添加 Expires 字段当浏览器再次发送请求时，先会对比当前时间和 Expires 对应的时间如果当前时间早于Expires 时间，那么直接使用缓存反之，需要再次发送请求.`因为服务器时间和客户端时间不一致导致可以修改客户端时间使用或者不准确`
2. Cache-Control
- no-cache，表示使用协商缓存，即每次使用缓存前必须向服务端确认缓存资源是否更新
- no-store，禁止浏览器以及所有中间缓存存储响应内容
- public，公有缓存，表示可以被代理服务器缓存，可以被多个用户共享
- private，私有缓存，不能被代理服务器缓存，不可以被多个用户共享
- max-age，以秒为单位的数值，表示缓存的有效时间
- must-revalidate，当缓存过期时，需要去服务端校验缓存的有效性

`协商缓存`的更新策略是不再指定缓存的有效时间了,而是浏览器直接发送请求到服务端进行确认缓存是否更新,如果请求响应返回的HTTP 状态为304,则表示缓存仍然有效,控制缓存的难题就是从浏览器端转移到了服务端
1. Last-Modified 和lf-Modified-Since
- 浏览器第一次请求资源，服务端在返回资源的响应头中加入Last-Modified 字段,该字段表示这个资源在服务端上的最近修改时间
- 当浏览器再次向服务端请求该资源时，请求头部带上之前服务端返回的修改时间这个请求头叫If-Modified-Since
- 服务端再次收到请求，根据请求头if-Modified-Since 的值，判断相关资源是否有变化如果没有则返回 304 Not Modified，并且不返回资源内容，浏览器使用资源缓存值否则正常返回资源内容，且更新 Last-Modified 响应头内容

`精度问题`-Last-Modified 的时间精度为秒，如果在1秒内发生修改，那么缓存判断可能会失效    
`准度问题`如果一个文件被修改，然后又被还原，内容并没有发生变化在这种情况下，浏览器的缓存还可以继续使用但因为修改时间发生变化，也会重新返回重复的内容

2. ETag 和 If-None-Match为了解决精度问题和准度问题HTTP提供了另一种不依赖于修改时间而依赖于文件哈希值的精确判断缓存的方式,那就是响应头部字段 ETag 和请求头部字段 If-None-Match
- 浏览器第一次请求资源，服务端在返响应头中加入 Etag 字段,Etag字段值为该资源的哈希值
- 当浏览器再次跟服务端请求这个资源时，在请求头上加上If-None-Match值为之前响应头部字段ETag 的值
- 服务端再次收到请求，将请求头if-None-Match 字段的值和响应资源的哈希值进行比对如果两个值相同，则说明资源没有变化，返回304 Not Modified否则就正常返回资源内容,无论是否发生变化，都会将计算出的哈希值放入响应头部的 ETag 字段中

`问题` 哈希值计算的开销

3. ServiceWorker 是浏览器在后台独立于网页运行的脚本也可以这样理解，它是浏览器和服务端之间的代理服务器，ServiceWorker 非常强大，可以实现包括推送通知和后台同步等功能更多功能还在进一步扩展，但其最主要的功能是实现离线缓存
- 使用限制   
- 在ServiceWorker 中无法直接访问 DOM但可以通过 postMessage 接口发送的消息来与其控制的页面进行通信
- ServiceWorker 只能在本地环境下或HTTPS 网站中使用
- ServiceWorker 有作用域的限制
- 一个ServiceWorker 脚本只能作用于当前路径及其子路径由于 
- ServiceWorker 属于实验性功能所以兼容性方面会存在一些问题