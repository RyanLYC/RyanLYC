### Number 
* 64位  1位符号位 - 指数E（11位） 0-1022表示为负，1024-2047表示为正 - 尾数M(52)
* 计算机表示 小数 是 * 2 取整 为 1 - 0.1 = 0.0001100110011001100110011001100110011001100110011001101  0.2 = 0.00110011001100110011001100110011001100110011001100110 ；so， 0.1 + 0.2 === 0.3 是 false

#### toFixed 与 toPrecision 区别 
* toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起 0.05.toPrecision(2) = 0.050 不进位
* toFixed 是小数点后指定位数取整，从小数点开始数起 0.05.toFixed(2) = 0.05 // 逢5 进 1

### Symbol
* Symbol(“bar”) === Symbol("bar"); // false
* Symbol.for("bar") === Symbol.for("bar");  // true

### Object.create
```js
Object.create f= function (o) {
  var F = flunction (){
    F.prototype = 0
    return new F()
  }
}

//  导致了
var a = {name: "LIN"};
var b= Object.create(a)

b.__proto__ === b.constructor.prototype; // false
b.__proto__ === Object.prototype  // false
b.__proto__ === a // false

// 用这个判断 instanceof ？
a.isPrototypeOf(b);
```

### 原型链遍历
* JavaScript引擎会先在对象的属性里去寻找属性，如果它找不到,就会再进一步往该对象的__proto__里面去寻找，直到某个对象的原型为null为止
* hasOwnProperty()、 Object.keys() - JavaScript 中唯一2个处理属性并且不会遍历原型链的方法

### Array 
* isArray()  判断是否是数组
* sort()  V8 引擎 sort 函数只给出了两种排序，InsertionSort 和 QuickSort，数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort
* 可以当 队列 和 栈 使用

### Map
* 键可以是任意值
* key 是有序的

Map和Object区别  
|        | key      | 数据访问 | 迭代 | Size | 性能 |
| ------ | -------- | -------- | ---- | ---- | ---- |
| Map    | 复杂类型 | .get()   | 是   | 是   | 好   |
| Object | 简单类型 | []       | 否   | 否   | 差   |

Object 的key 默认调用 .toString()

` 具体 查看 JavaScript 目录下的 Set、Map、WeakSet 和 WeakMap 的区别` 

### BOM
#### location
- hash 设置或返回从井号 (#) 开始的 URL
- host 设置或返回主机名和当前 URL 的端口号
- hostname 设置或返回当前 URL 的主机名
- href 设置或返回完整的 URL
- pathname 设置或返回当前 URL 的路径部分
- port 设置或返回当前 URL 的端口号
- protocol 设置或返回当前 URL 的协议
- search 设置或返回从问号 (?) 开始的 URL
- location.assign("http://baidu.com")
- location.href = "http://baidu.com"
- location.replace("http://baidu.com") 不会留history记录

#### Navigator
* userAgent  
- 通过useragent获取手机品牌型号
- https://github.com/fex-team/ua-device 一个用于解析UA来得到用户终端信息的JS库

* clipboard - 剪贴板内容  

* keyboard - getLayoutMap()  lock()   unlock()

* H5地理定位 - Geolocation.getCurrentPosition()   
* IP定位 -  https://api.map.baidu.com/location/ip   https://pv.sohu.com/cityjson?ie=utf-8  https://www.taobao.com/help/getip.php    

*  mediaDevices  WebRTC Real-Time Communications实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输

#### serviceWorker
  基于web worker，独立于JavaScript主线程的独立线程，不会堵塞主线程。在web worker的基础上增加了离线缓存的能力，充当服务器与浏览器之间的代理服务器，可以拦截全站的请求，并作出相应的动作，支持推送，可以控制管理缓存的内容以及版本 - PWA 技术


#### 其他 BOM
* screen
* history
* performance - 性能API
* window

### 更靠谱的随机数
- 常开发开始推荐使用 `Math.random() `方法，高性能且实用，但是如果我们的`随机值与加密相关`，或者`涉及到金钱等安全性要求非常高的场景`，务必使用 `getRandomValues()` 方法
- Crypto对象与其他随机值 
```js

var arr = new Uint32Array(2)
window.crypto.getRandomValues(arr);


let uuid = self.crypto.randomUUID();
console.log(uuid);

```

#### indexedDB
- 浏览器提供的本地数据库，支持事务、索引
- Cookie - 4kb
- LocalStorage 2.5M - 10M
- indexedDB - 可用空间的 50%
  

### DOM

#### 尺⼨和定位
- 尺寸  style.width  getComputedStyle offsetWidth clientWidth  getBoudingClientRect
- 定位  offsetTop  offsetLeft

#### JS优化--- createDocumentFragment()
- 动态创建html节点的方法
  * createAttribute(name)	用指定名称name创建特性节点
  * createComment(text)	创建带文本text的注释节点
  * createDocumentFragment()	创建文档碎片节点
  * createElement(tagname)	创建标签名为tagname的节点
  * createTextNode(text)	创建包含文本text的文本节点
  
DocumentFragment （文档碎片节点）是一个插入结点时的过渡，我们把要插入的结点先放到这个文档碎片里面，然后再一次性插入文档中，这样就减少了页面渲染DOM元素的次数.
```js
// 用法示例
for (var i = 0; i < 1000; i++)
  {
    var el = document.createElement('p');
    el.innerHTML = i;
    document.body.appendChild(el); //直接用appendChild向文档中插入节点
  }

  var frag = document.createDocumentFragment();
for (var i = 0; i < 1000; i++)
{
  var el = document.createElement('p');
  el.innerHTML = i; 
  frag.appendChild(el); //首先将新节点先添加到DocumentFragment 节点
}
document.body.appendChild(frag);//然后用appendChild插入文档中
```

- 引起重排的操作：
1. 浏览器窗口大小发生改变
2. 元素尺寸或位置发生改变
3. 元素内容变化（文字数量或图片大小等等）
4. 添加或者删除可见的DOM元素
5. 激活CSS伪类（例如：:hover）
6. 查询某些属性或调用某些方法

- 优化
1. 避免频繁操作样式
2. 避免频繁操作DOM（fragment，Vitual Dom）
3. 避免频繁读取引发reflow的属性
4. 创建图层（transfer，will-change）
5. 不要使用table布局

- 引起回流的属性和方法
* clientWidth、clientHeight、clientTop、clientLeft   
* offsetWidth、offsetHeight、offsetTop、offsetLeft    
* scrollWidth、scrollHeight、scrollTop、scrollLeft   
* scrollIntoView()、scrollIntoViewIffNeeded()   
* getComputedStyle()   
* getBoundingClientRect()   
* scrollTo()  

### CSS
#### Flex
#### Grid - https://gridbyexample.com/examples/
#### 盒模型
- W3C 标准盒模型 - box-sizing: content-box
- 怪异盒模型 - box-sizing: border-box

* mix(#000, #fff, 10%) //按比例权重混合颜色
* adjust-hue(#f36,150deg) //改变#f36颜色的色相值为150deg
* lighten(#f36,50%) //把#f36颜色亮度提高50%
* darken(#f36,50%) //把#f36颜色亮度降低50%
* saturate(#f36,50%) //把#f36颜色饱和度提高50%
* desaturate(#f36,50%) //把#f36颜色饱和度降低50%
* opacify(#f36, 0.5) //把颜色的透明度变成50%
* grayscale(#f36) //把#f36颜色变成灰色

### 浏览器
- 浏览器缓存 顺序 Service Worker - Memory Cache（浏览器内部） -  Disk Cache（强制/协商） - Push Cache （推送缓存 -是 HTTP/2 中的内容）
- 缓存分类 强制缓存 - Expires Cache-Control 协商缓存  - Last-modify Etag

### 正则表达式

### JavaScript内存管理
- 内存回收

* 年轻代 两块内存 互换，清理碎片，多次使用存放年老代中
* 年老代 标记 删除
* 大对象 不会被回收

`在进行 GC 期间，整个系统会被挂起`